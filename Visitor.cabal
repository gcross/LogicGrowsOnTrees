Name:                Visitor
Version:             1.0
License:             BSD3
License-file:        LICENSE
Author:              Gregory Crosswhite
Maintainer:          Gregory Crosswhite <gcrosswhite@gmail.com>
Stability:           Provisional
Synopsis:            a distributed (parallel) implementation of logic programming via. dynamically generated trees
Description:         You can think of this package in two equvalent ways. First,
                     you can think of it as an implementation of logic
                     programming that is designed to be parellelized using
                     workers that have no memory shared between them (hence,
                     "distributed"), which means that one can use supercomputers
                     with large numbers of nodes. Second, one can think of this
                     package as providing infrastructure for exploring a tree in
                     parallel. The connection between these two perspectives is
                     that logic programming involves making nondeterministic
                     choices, and each such choice is equivalent to a branch
                     point in a tree representing the search space of the
                     logic program.  In the rest of the documentation we will
                     focus on the tree perspective simply because a lot of the
                     functionality makes the most sense from the perspective of
                     working with trees, but one is always free to ignore this
                     and simply write a logic program using the standard
                     approach of using 'MonadPlus' to indicate choice and
                     failure, and the 'Tree' implementation of this typeclass
                     will take care of the details of turning your logic program
                     into tree.
                     .
                     To use this package, you first write a function that builds
                     a tree (say, by using logic programming); the "Visitor"
                     module provides functionality to assist in this. You may
                     have your function either return a generic 'MonadPlus' or
                     'MonadVisitable' (where the latter lets you cache expensive
                     intermediate calculations so that they do not have to be
                     performed again if this path is re-explored later), or you
                     may have it directly return a 'TreeGenerator' (or one of
                     its impure friends) directly. You can then test your tree
                     generator using the visting functions in the "Visitor"
                     module.
                     .
                     WARNING: If you need something like state in your
                     generator, then you should stack the state monad (or
                     whatever else you want) /on top/ of 'TreeGenerator' rather
                     than below it. The reason for this is that if you stack the
                     monad below 'TreeGeneratorT' then your monad will be
                     affected by the order in which the tree is visited, which
                     is almost never what you want, in part because if you are
                     not careful then you will break the assumption made by the
                     checkpointing and parallelization infrastructure that it
                     does not matter in what order the tree is explored or even
                     whether some parts are explored twice or not at all in a
                     given run.  If side-effects that are not undone by
                     backtracking is indeed what you want, then you need to make
                     sure that your side-effects do not break this assumption;
                     for example, a monad which memoizes a pure function is
                     perfectly fine. By contrast if you are working within IO
                     monad and writing results to a database rather than
                     returning them (and assuming that duplicate results would
                     cause problems) then you need to check to make sure you
                     aren't writing the same result twice, such as by using the
                     "Visitor.Location" functionality to identify where you are
                     in the tree so you can query to see if your current
                     location is already listed in the database.
                     .
                     If you want to see examples of writing a tree generator,
                     see the "Visitor.Examples.Queens" module which has some
                     basic examples of using logic programming to find and/or
                     count the number of solutions to the n-queens problem for
                     a given board size.  The "Visitor.Examples.Queens.Advanced"
                     module has my own solution to the module where I used
                     symmetry breaking to prune the search tree,  cutting the
                     runtime by about a third;  the resulting code is very
                     complex, though.
                     .
                     Once your tree generator is finished, you can start
                     taking advantage of the major features of this package.
                     If you are interested in checkpointing but not
                     parallelization, then you can use the step functions in
                     the "Visitor.Checkpoint" module to sequentially visit a
                     tree one node at a time, saving the current checkpoint as
                     often as you desire;  at any time the visiting can be
                     aborted and resumed later.
                     .
                     Most likely, though, you will be interested in
                     using the parallelization infrastructure rather than just
                     the checkpointing infrastructure.  The parallelization
                     infrastructure uses a supervisor/worker model, and is
                     designed such that the logic used to keep track of the
                     workers and the current progress is abstracted away into
                     the "Visitor.Parallel.Common.Supervisor" module which can
                     be re-used for various "back-ends" such as threads,
                     processes, network, and MPI, all but the first of which are
                     provided in separate packages.  Parallelization is obtained
                     via. stealing a workload from a worker;  specifically, a
                     selected worker will look back at the (non-frozen) choices
                     it has made so far, pick the first one, freeze it (so that
                     it won't backtrack and try the other branch), and then hand
                     the other branch to the supervisor which will then give it
                     to a waiting worker.
                     .
                     To use the parallelization infrastructure, you have two
                     choices.  First, you can opt to use the back-end directly;
                     the visiting functions provided by the back-end are
                     relatively simple (compared to the alternative to be
                     discussed in a moment) and they furthermore give you
                     maximum control over the back-end, but the downside is that
                     you will have to re-implement features such as regular
                     checkpointing and forwarding information from the command
                     line to the workers yourself.  Second, you can use the
                     infrastructure in "Visitor.Parallel.Main", which automates
                     most of the process for you, including parsing the command
                     lines, sending information to the workers, determining
                     how many workers (if applicable) to start up, offering the
                     user a command line option to specify whether, where and
                     how often to checkpoint, etc.;  furthermore, this
                     infrastructure is completely back-end independent, which
                     means that when switching from one back-end to another
                     all you have to do is change one of the arguments in your
                     call to the main function you are using in
                     "Visitor.Parallel.Main".  The downside is that the call to
                     use this functionality is a bit more complex than the call
                     to use a particular back-end precisely because of its
                     generality.
                     .
                     If you want to see examples of using the
                     "Visitor.Parallel.Main" module, check out the example
                     executables in the examples/ subdirectory of the source
                     distribution.
                     .
                     If you are interested in writing a new back-end, then there
                     are a couple of possibilities.  First, if your back-end
                     can spawn and destroy workers on demand, then you should
                     look at the "Visitor.Parallel.Common.Workgroup" module as
                     it has infrastructure designed for this case;  look at
                     "Visitor.Parallel.BackEnd.Threads" for an example of
                     using it.  Second, if your back-end does not meet this
                     criteria, then you should look at the
                     "Visitor.Parallel.Common.Supervisor" module;  your back-end
                     will need to run within the 'SupervisorMonad', with its
                     own state contained in its own monad below
                     'SupervisorMonad' monad in the stack;  for an example,
                     look at the @Visitor-network@ module.
                     .
                     NOTE: This package uses the @hslogger@ package for logging;
                     if you set the log level to INFO or DEBUG (either by
                     calling the functions in @hslogger@ yourself or by using
                     the @-l@ command line option if you are using Main) then
                     many status messages will be printed to the screen (or
                     wherever else the log has been configured to be written).
                     .
                     The modules are organized as follows:
                     .
                        ["Visitor"] basic infrastructure for generating and visiting search trees
                     .
                        ["Visitor.Checkpoint"] infrastructure for creating and stepping through checkpoints
                     .
                        ["Visitor.Examples.Queens"] simple examples of solving the n-quees problem
                     .
                        ["Visitor.Examples.Queens.Advanced"] a very complicated example of solving the n-queens problem using symmetry breaking
                     .
                        ["Visitor.Location"] infrastructure for when you want your tree generator to have knowledge of its current location within the tree
                     .
                        ["Visitor.Parallel.BackEnd.Threads"] the threads back-end
                     .
                        ["Visitor.Parallel.Common.Message"] common infrastructure for exchanging messages between worker and supervisor
                     .
                        ["Visitor.Parallel.Common.Process"] common infrastricture for the case where a worker has specific communications channels for sending and recieving messages; it might seem like this should always be the case, but it is not true for threads as the supervisor has direct access to the worker thread, nor for MPI which has its own idiosyncratic communication model
                     .
                        ["Visitor.Parallel.Common.Supervisor"] common infrastructure for keeping track of the state of workers and of the system of a whole, including determining when the run is over
                     .
                        ["Visitor.Parallel.Common.Supervisor.RequestQueue"] infrastructure for sending requests to the 'SupervisorMonad' from another thread
                     .
                        ["Visitor.Parallel.Common.VisitorMode"] specifies the various modes in which the visiting can be done
                     .
                        ["Visitor.Parallel.Common.Worker"] contains the workhorse of the parallel infrastructure:  a thread that steps through a given workload while continuously polling for requests
                     .
                        ["Visitor.Parallel.Common.Workgroup"] common infrastructure for the case where workers can be added and removed from the system on demand
                     .
                        ["Visitor.Parallel.Main"] a unified interface to the various back-ends that automates much of the process such as processing the command, forwarding the needed information to the workers, and performing regular checkpointing if requested via. a command line argument
                     .
                        ["Visitor.Path"] infrastructure for working with paths trough the search tree
                     .
                        ["Visitor.Utils.Handle"] a couple of utility functions tfor exchanging serializable data over handles
                     .
                        ["Visitor.Utils.IntSum"] a monoid that contains an 'Int' to be summed over
                     .
                        ["Visitor.Utils.MonadPlusForest"] provides an algorithm for efficiently building up a tree from a sequence of leaves
                     .
                        ["Visitor.Utils.PerfectTree"] provides algorithms for generating various simple trees
                     .
                        ["Visitor.Utils.WordSum"] a monoid that contains an 'Word' to be summed over
                     .
                        ["Visitor.Workload"] infrastructure for working with 'Workload's

Cabal-version:       >=1.8
Build-type:          Simple
Category:	     

Source-Repository head
  Type:                git
  Location:            git://github.com/gcross/Visitor.git

Source-Repository this
    Type:                git
    Location:            git://github.com/gcross/Visitor.git
--    Tag:                 


Library
    Build-depends:
        AbortT-transformers == 1.0.*,
        AbortT-mtl == 1.0.*,
        array == 0.4.*,
        base > 4 && < 5,
        bytestring >= 0.9 && < 0.11,
        cereal == 0.3.*,
        cmdtheline == 0.2.*,
        composition >= 0.2 && < 1.1,
        containers >= 0.4 && < 0.6,
        data-ivar == 0.30.*,
        derive >= 2.5.11 && < 2.6,
        directory >= 1.1 && < 1.3,
        either-unwrap == 1.1.*,
        hslogger == 1.2.*,
        hslogger-template == 2.0.*,
        lens >= 3.8 && < 3.10,
        MonadCatchIO-transformers == 0.3.*,
        monoid-statistics == 0.3.*,
        mtl == 2.1.*,
        multiset == 0.2.*,
        operational == 0.2.*,
        prefix-units == 0.1.*,
        pretty == 1.1.*,
        PSQueue == 1.1.*,
        sequential-index == 0.2.*,
        stm >= 2.3 && < 2.5,
        time == 1.4.*,
        transformers >= 0.2 && < 0.4,
        void == 0.6.*,
        yjtools >= 0.9.7 && < 0.10
    Exposed-modules:
        Visitor
        Visitor.Checkpoint
        Visitor.Examples.Queens
        Visitor.Examples.Queens.Advanced
        Visitor.Location
        Visitor.Parallel.BackEnd.Threads
        Visitor.Parallel.Common.ExplorationMode
        Visitor.Parallel.Common.Message
        Visitor.Parallel.Common.Process
        Visitor.Parallel.Common.Supervisor
        Visitor.Parallel.Common.Supervisor.RequestQueue
        Visitor.Parallel.Common.Workgroup
        Visitor.Parallel.Common.Worker
        Visitor.Parallel.Main
        Visitor.Path
        Visitor.Utils.Handle
        Visitor.Utils.IntSum
        Visitor.Utils.MonadPlusForest
        Visitor.Utils.PerfectTree
        Visitor.Utils.WordSum
        Visitor.Workload
    Other-modules:
        Visitor.Parallel.Common.Supervisor.Implementation
        Visitor.Utils.Word_
    HS-source-dirs: sources
    C-sources: c-sources/queens.c
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing
    if flag(pattern-warnings)
        GHC-Options: -fwarn-incomplete-patterns

Flag warnings
    Description: Enables most warnings.
    Default:     False

Flag pattern-warnings
    Description: Enables only pattern match warnings.
    Default:     False

Flag examples
    Description: Enable building the executables.
    Default:     False

Executable count-all-nqueens-solutions
    Main-is: count-all-nqueens-solutions.hs
    Hs-source-dirs: examples
    Build-depends:
        Visitor,
        base > 4 && < 5,
        cmdtheline == 0.2.*
    if flag(examples)
        Buildable: True
    else
        Buildable: False
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing -threaded
    else
        GHC-Options: -threaded

Executable print-all-nqueens-solutions
    Main-is: print-all-nqueens-solutions.hs
    Hs-source-dirs: examples
    Build-depends:
        Visitor,
        base > 4 && < 5,
        cmdtheline == 0.2.*,
        containers >= 0.4 && < 0.6
    if flag(examples)
        Buildable: True
    else
        Buildable: False
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing -threaded
    else
        GHC-Options: -threaded

Executable print-an-nqueens-solution
    Main-is: print-an-nqueens-solution.hs
    Hs-source-dirs: examples
    Build-depends:
        Visitor,
        base > 4 && < 5,
        cmdtheline == 0.2.*,
        containers >= 0.4 && < 0.6
    if flag(examples)
        Buildable: True
    else
        Buildable: False
    if flag(warnings)
        GHC-Options: -Wan -fno-warn-name-shadowing -threaded
    else
        GHC-Options: -threaded

Executable print-some-nqueens-solutions-using-pull
    Main-is: print-some-nqueens-solutions-using-pull.hs
    Hs-source-dirs: examples
    Build-depends:
        Visitor,
        base > 4 && < 5,
        cmdtheline == 0.2.*,
        containers >= 0.4 && < 0.6
    if flag(examples)
        Buildable: True
    else
        Buildable: False
    if flag(warnings)
        GHC-Options: -Wsome -fno-warn-name-shadowing -threaded
    else
        GHC-Options: -threaded

Executable print-some-nqueens-solutions-using-push
    Main-is: print-some-nqueens-solutions-using-push.hs
    Hs-source-dirs: examples
    Build-depends:
        Visitor,
        base > 4 && < 5,
        cmdtheline == 0.2.*,
        containers >= 0.4 && < 0.6
    if flag(examples)
        Buildable: True
    else
        Buildable: False
    if flag(warnings)
        GHC-Options: -Wsome -fno-warn-name-shadowing -threaded
    else
        GHC-Options: -threaded

Executable count-all-trivial-tree-leaves
    Main-is: count-all-trivial-tree-leaves.hs
    Hs-source-dirs: examples
    Build-depends:
        Visitor,
        base > 4 && < 5,
        cereal == 0.3.*,
        cmdtheline == 0.2.*,
        composition >= 0.2 && < 1.1
    if flag(examples)
        Buildable: True
    else
        Buildable: False
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing -threaded
    else
        GHC-Options: -threaded

Benchmark balancers
    Type: exitcode-stdio-1.0
    Main-is: balancers.hs
    Hs-source-dirs: benchmarks
    Build-depends:
        Visitor,
        base > 4 && < 5,
        criterion >= 0.6 && < 0.9
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing

Benchmark tree-generator-versus-list-trivial-tree
    Type: exitcode-stdio-1.0
    Main-is: tree-generator-versus-list-trivial-tree.hs
    Hs-source-dirs: benchmarks
    Build-depends:
        Visitor,
        base > 4 && < 5,
        criterion >= 0.6 && < 0.9
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing

Benchmark tree-generator-versus-list-nqueens
    Type: exitcode-stdio-1.0
    Main-is: tree-generator-versus-list-nqueens.hs
    Hs-source-dirs: benchmarks
    Build-depends:
        Visitor,
        base > 4 && < 5,
        criterion >= 0.6 && < 0.9
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing

Test-Suite tests
    Type: exitcode-stdio-1.0
    Main-is: tests.hs
    Hs-source-dirs: tests
    Build-depends:
        Visitor,
        base > 4 && < 5,
        bytestring >= 0.9 && < 0.11,
        cereal == 0.3.*,
        composition >= 0.2 && < 1.1,
        containers >= 0.4 && < 0.6,
        data-ivar == 0.30.*,
        dlist == 0.5.*,
        either-unwrap == 1.1.*,
        hslogger == 1.2.*,
        hslogger-template == 2.0.*,
        HUnit == 1.2.*,
        lens >= 3.8 && < 3.10,
        operational == 0.2.*,
        random == 1.0.*,
        QuickCheck >= 2.4 && < 2.7,
        quickcheck-instances >= 0.3.1 && < 0.4,
        smallcheck == 1.0.*,
        stm >= 2.3 && < 2.5,
        test-framework >= 0.6 && < 0.9,
        test-framework-hunit >= 0.2 && < 0.4,
        test-framework-quickcheck2 >= 0.2 && < 0.4,
        test-framework-smallcheck == 0.2.*,
        transformers >= 0.2 && < 0.4,
        uuid == 1.2.*,
        void == 0.6.*
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing -with-rtsopts=-M256M
    else
        GHC-Options: -with-rtsopts=-M256M

Test-Suite test-nqueens
    Type: exitcode-stdio-1.0
    Main-is: test-nqueens.hs
    Hs-source-dirs: tests
    Build-depends:
        Visitor,
        base > 4 && < 5,
        containers >= 0.4 && < 0.6,
        HUnit == 1.2.*,
        QuickCheck >= 2.4 && < 2.7,
        test-framework >= 0.6 && < 0.9,
        test-framework-hunit >= 0.2 && < 0.4,
        test-framework-quickcheck2 >= 0.2 && < 0.4,
        transformers >= 0.2 && < 0.4
    if flag(warnings)
        GHC-Options: -Wall -fno-warn-name-shadowing
